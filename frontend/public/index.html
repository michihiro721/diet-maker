<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <!-- viewportメタタグを修正 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="トレーニングの管理と記録をサポートする「ダイエットメーカー」"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-W5KQHY7KT0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-W5KQHY7KT0');
    </script>
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>ダイエットメーカー</title>
    
    <!-- 上下左右のオーバースクロールを完全に防止するスタイル -->
    <style>
      html {
        height: 100%;
        width: 100%;
        overflow: hidden;
        position: fixed;
        overscroll-behavior: none;
        background-color: #fff;
      }
      
      body {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        overflow: auto;
        position: fixed;
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
        touch-action: none;
        background-color: #fff;
      }
      
      #root {
        height: 100%;
        width: 100%;
        overflow: auto;
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
      }

      /* コンテンツコンテナでスクロールを許可 */
      [class$="-container"] {
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
        /* 縦スクロールのみ許可 */
        touch-action: pan-y;
      }
      
      /* iOS固有の修正 */
      @supports (-webkit-touch-callout: none) {
        body, #root, [class$="-container"] {
          /* iOS用の高さ調整 */
          height: -webkit-fill-available;
        }
      }
    </style>
    
    <!-- タッチイベントを完全に制御するスクリプト -->
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // すべてのタッチイベントをキャプチャして制御
        document.addEventListener('touchstart', function(e) {
          // 境界でのタッチイベントをチェック
          if (isAtBoundary(e)) {
            e.preventDefault();
          }
        }, { passive: false });
        
        document.addEventListener('touchmove', function(e) {
          // 複数タッチ（ズーム）や境界でのスクロールを防止
          if (e.touches.length > 1 || isAtBoundary(e)) {
            e.preventDefault();
          }
        }, { passive: false });
        
        // スクロール境界をチェックする関数
        function isAtBoundary(e) {
          const target = e.target;
          const scrollableParent = findScrollableParent(target);
          
          if (!scrollableParent) return false;
          
          // 上端か下端にあるかチェック
          const atTop = scrollableParent.scrollTop <= 0;
          const atBottom = scrollableParent.scrollHeight - scrollableParent.scrollTop <= scrollableParent.clientHeight + 1;
          
          // 上または下の境界にいて、その方向へスクロールしようとしている場合
          return (atTop && e.touches[0].clientY > e.touches[0].clientY) || 
                 (atBottom && e.touches[0].clientY < e.touches[0].clientY);
        }
        
        // スクロール可能な親要素を見つける関数
        function findScrollableParent(element) {
          if (!element) return null;
          
          if (element === document.body || element === document.documentElement) {
            return document.body;
          }
          
          const style = window.getComputedStyle(element);
          const overflowY = style.getPropertyValue('overflow-y');
          
          if (overflowY === 'auto' || overflowY === 'scroll') {
            return element;
          }
          
          return findScrollableParent(element.parentElement);
        }
        
        // iOSでの特別な処理
        if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
          // ダブルタップによるズームを防止
          document.addEventListener('touchend', function(e) {
            const now = Date.now();
            const timeDiff = now - (this.lastTouchEnd || 0);
            
            if (timeDiff < 300 && e.touches.length === 0) {
              e.preventDefault();
            }
            
            this.lastTouchEnd = now;
          }, { passive: false });
          
          // ピンチズームを明示的に防止
          document.documentElement.addEventListener('gesturestart', function(e) {
            e.preventDefault();
          }, { passive: false });
        }
      });
    </script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>